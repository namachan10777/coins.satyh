@require: math
@require: code
@require: color
@require: pervasives
@require: list
@require: option

type credit-to = (string * inline-text * float)
type credit-from = (inline-text * float * inline-text * inline-text)
type convert-unit = (credit-to list * credit-from list)
type category = inline-text * (convert-unit list)

type credit-info = (|
  name: inline-text;
  date: inline-text;
  dean: inline-text;
  faculty: inline-text;
  department: inline-text;
  grade: int;
  id: int;
  graduated-school-duration: (inline-text * inline-text);
  tsukuba-duration: (inline-text * inline-text);
  graduated-school: inline-text;
|)

module CreditConvert : sig
  val document : credit-info -> (category list) list -> document
end = struct

  let font-ratio-latin = 1.
  let font-ratio-cjk = 0.88
  let font-cjk-mincho   = (`ipaexm`    , font-ratio-cjk  , 0.)
  let font-cjk-gothic   = (`ipaexg`    , font-ratio-cjk  , 0.)
  let font-latin-roman  = (`Junicode`   , font-ratio-latin, 0.)

  let get-standard-context wid =
    get-initial-context wid (command \math)
      |> set-code-text-command (command \code)
      |> set-dominant-wide-script Kana
      |> set-language Kana Japanese
      |> set-language HanIdeographic Japanese
      |> set-dominant-narrow-script Latin
      |> set-language Latin English
      |> set-font Kana           font-cjk-mincho
      |> set-font HanIdeographic font-cjk-mincho
      |> set-font Latin          font-latin-roman
      |> set-math-font `lmodern`
      |> set-hyphen-penalty 100
      |> set-font-size 10pt



  let header ctx =
    read-inline ctx {別記様式第６号（第１５号関係）}

  let-rec join sep l = match l with
    | [] -> []
    | [x] -> [x]
    | x :: xs -> x :: sep :: join sep xs

  let ib-space-between ctx width itl =
    let ibl = List.map (read-inline ctx) itl in
    let ibl-width-total =
      ibl
      |> List.map (fun ib -> get-natural-width ib)
      |> List.fold-left (+') 0pt in
    let skip-width =
      (width -' ibl-width-total) *' (1pt /' (1pt *' (float ((List.length ibl) - 1))))
    in
      ibl
      |> join (inline-skip skip-width)
      |> List.fold-left (++) inline-nil

  let belongs ctx r =
    let e = EmptyCell in
    let pads = (2pt, 2pt, 7pt, 7pt) in
    let nc ib = NormalCell(pads, ib) in
    let mc w h ib = MultiCell(h, w, pads, ib) in
    let ncw-r target-w it =
      let ib = read-inline ctx it in
      let w = get-natural-width ib in
      NormalCell(pads, inline-skip (target-w -' w) ++ ib)
    in
    let name = r#name in
    let faculty = r#faculty in
    let department = r#department in
    let grade = embed-string (arabic (r#grade)) in
    let id = embed-string (arabic (r#id)) in
    let cells = [
      [nc (ib-space-between ctx 1.5cm {|所|属|}); ncw-r 2.5cm {#faculty;学群}; ncw-r 2.5cm {#department;学類}; ncw-r 2.5cm {#grade;年次}];
      [nc (ib-space-between ctx 1.5cm {|学|籍|番|号|}); mc 3 1 (inline-fil ++ (read-inline ctx id)); e; e];
      [nc (ib-space-between ctx 1.5cm {|氏|名|}); mc 3 1 (inline-fil ++ read-inline ctx name); e; e];
    ]
    in
    tabular cells (fun _ _ -> [])

  let brace-right hgt color point =

    let fontsize = hgt *' 0.4 in
    let halflen = hgt *' 0.5 in
    let hgtaxis = hgt *' 0.5 in

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = w-extra +' fontsize *' 0.125 in
    let x1 = w-extra +' fontsize *' 0.25 in
    let x3 = x1 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x1 +' fontsize *' 0.0625 in
    let x7 = w-extra +' fontsize *' 0.225 in

    let p0 = w-extra +' fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x1 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x5 +' w6 in
    let p7 = w-extra +' fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 in
    let q2 = y2 in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 in
    let q6 = y6 in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x4 -' x +' w-extra, ycenter +' y) in
      let fN (x, y) = (xpos +' x4 -' x +' w-extra, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x1, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x5, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x5, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x1, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    [ fill color (path point); ]

  let from-rule ctx =
    let pads = (5pt, 5pt, 10pt, 10pt) in
    let e = EmptyCell in
    let nc ib = NormalCell(pads, ib) in
    let mc w h ib = MultiCell(h, w, pads, ib) in
    let rule1 = read-inline ctx {１ 国立大学法人筑波大学学群学則第３６条} in
    let rule2 = read-inline ctx {２ 国立大学法人筑波大学学群学則第３７条} in
    let sep =
      inline-graphics 10pt 40pt 0pt (brace-right 40pt Color.black) in
    let body =
      let ctx = ctx
        |> set-paragraph-margin 0pt 0pt
      in
      let itl = {|の規定により単位の認定を受けたいので、下記のとおり|申請します。|} in
      embed-block-top ctx 170pt (fun ctx ->(
        let bb = itl
        |> List.map (fun it -> line-break true true ctx (read-inline ctx it))
        |> List.fold-left (+++) block-nil
        in bb +++ block-skip 5pt))
    in
    let cells = [
      [nc rule1; mc 1 2 sep; mc 1 2 body];
      [nc rule2; e; e];
    ]
    in
    tabular cells (fun _ _ -> [])

  let main-title ctx r =
    let ctx = ctx |> set-paragraph-margin 0pt 0pt in
    let lb = line-break true true ctx in
    let ri = read-inline ctx in
    let dean = r#dean in
    let faculty = r#faculty in
    [
      lb (inline-fil ++ ri {他大学等において修得した単位等に係る単位認定申請書} ++ inline-fil);
      lb (inline-fil ++ ri r#date);
      lb (ri  {#faculty;学郡長　#dean;殿});
      lb (inline-fil ++ belongs ctx r);
      lb (from-rule ctx);
      block-skip 5pt;
      lb (inline-fil ++ ri {記} ++ inline-fil)
    ] |> List.fold-left (+++) block-nil

  let graduated-school-info ctx r =
    let centering-with-w target-w ib = 
      let w = get-natural-width ib in
      let skip = (target-w -' w) *' 0.5 in
      inline-skip skip ++ ib ++ inline-skip skip
    in
    let ctx-date = ctx |> set-font-size 9pt in
    let graduated-school = r#graduated-school in
    let ri = read-inline ctx in
    let pads = (0pt, 0pt, 5pt, 5pt) in
    let e = EmptyCell in
    let nc ib = NormalCell(pads, ib) in
    let mc w h ib = MultiCell(h, w, pads, ib) in
    let (tsukuba-from, tsukuba-to) = r#tsukuba-duration in
    let (graduated-from, graduated-to) = r#graduated-school-duration in
    let cells = [
      [
        nc (centering-with-w 7cm (ri {単位の習得等を行った大学等}));
        nc (centering-with-w 6cm (ri {単位の習得等を行った時期}));
        nc (centering-with-w 4.5cm (ri {添付する書類}));
      ];
      [
        mc 1 4 (inline-fil ++ ri {#graduated-school;} ++ inline-fil);
        nc (ri {１　筑波大学在学中});
        nc (ri {１　成績証明書});
      ];
      [
        e;
        nc (read-inline ctx-date {（#tsukuba-from;〜#tsukuba-to;）});
        nc (ri {２　修了（在学）証明書});
      ];
      [
        e;
        nc (ri {１　筑波大学入学前});
        nc (ri {３　その他});
      ];
      [
        e;
        nc (read-inline ctx-date {（#graduated-from;〜#graduated-to;）});
        e;
      ]
    ]
    in
    let gen-line xs ys = match (xs, ys) with
      | (x1 :: x2 :: x3 :: x4 :: [], y1 :: y2 :: _ :: y4 :: _ :: y6 :: []) -> (
          let bold p1 p2 = stroke 1pt Color.black (Gr.line p1 p2) in
          let hlines = List.map (fun y -> bold (x1, y) (x4, y)) in
          let vlines = List.map (fun x -> bold (x, y1) (x, y6)) in
          bold (x2, y4) (x3, y4) ::
          List.concat [
            hlines [y1; y2; y6];
            vlines xs;
          ]
      )
      | _ -> []
    in
    line-break true true ctx (tabular cells gen-line)

  let string-of-float _ = ` `

  let-rec gen-conversion-cells ctx conversions =
    let pads = (1pt, 1pt, 1pt, 1pt) in
    let nc it = NormalCell(pads, read-inline ctx it) in
    let e = EmptyCell in
    match conversions with
    | (t :: ts, f :: fs) -> (
        let (to-id, to-title, to-credit) = t in
        let (from-title, from-credit, from-grade, from-remark) = f in
        [nc (embed-string to-id); nc to-title; nc (to-credit |> string-of-float |> embed-string);
          nc from-title;nc (from-credit |> string-of-float |> embed-string); nc from-grade; nc from-remark]
        :: gen-conversion-cells ctx (ts, fs)
    )
    | (t :: ts, []) -> (
        let (to-id, to-title, to-credit) = t in
        [nc (embed-string to-id); nc to-title; nc (to-credit |> string-of-float |> embed-string);
          e; e; e; e]
        :: gen-conversion-cells ctx (ts, [])
    )
    | ([], f :: fs) -> (
        let (from-title, from-credit, from-grade, from-remark) = f in
        [e; e; e;
          nc from-title;nc (from-credit |> string-of-float |> embed-string); nc from-grade; nc from-remark]
        :: gen-conversion-cells ctx ([], fs)
    )
    | ([], []) -> []

  let gen-category-cells ctx category =
    let (category-name, conversions) = category in
    let conversion-cells = List.map (gen-conversion-cells ctx) conversions in
    let (_, separates) = List.fold-left (fun (len-total, separates) conversion-cell -> (
      let h = len-total + List.length conversion-cell in
      (h, h :: separates))) (0, []) conversion-cells
    in
    let cells = conversion-cells |> List.concat |> List.map (fun row -> EmptyCell :: row) in
    (cells, separates)

  let conversion-table ctx tbl =
    let pads = (5pt, 5pt, 2pt, 2pt) in
    let ri = read-inline ctx in
    let e = EmptyCell in
    let nc ib = NormalCell(pads, ib) in
    let index-cell it = nc (inline-fil ++ ri it ++ inline-fil) in
    let mc w h ib = MultiCell(h, w, pads, ib) in
    let ad-hoc-hack = inline-graphics 0pt 7pt 0pt (fun _ -> []) in
    let h1 = ri {認定を希望する授業科目} in
    let h2 = ri {認定の対象となる他大学等において修得した単位等} in
    let header = [
      [nc ad-hoc-hack; mc 3 1 (inline-skip 0pt ++ h1 ++ inline-fil); e; e; mc 4 1 h2; e; e; e];
      [index-cell {科目区分};index-cell {科目番号}; index-cell {授業科目名};index-cell {単位数};
        index-cell {授業科目名}; index-cell {単位等}; index-cell {評価等}; index-cell {備考};];
    ]
    in
    let footer = [
      [e; e; nc (ri {小計}); e; nc (ri {小計}); e; e; e];
    ]
    in
    let categories = List.map (gen-category-cells ctx) tbl in
    let (_, main-separates, sub-separates) = List.fold-left
      (fun (h-total, main-separates, sub-separates) (category-cells, category-separates) -> (
        let sub-separates = List.append category-separates (List.map (fun h -> h + h-total) sub-separates) in
        let h-total = h-total + List.length category-cells in
        let main-separates = h-total :: main-separates in
        (h-total, main-separates, sub-separates)))
      (0, [], []) categories
    in
    let categories-cells = categories |> List.map (fun (cells, _) -> cells) |> List.concat in
    let cells = List.concat [header; categories-cells; footer] in
    let gen-line xs ys = match (xs, ys, List.reverse ys) with
      | (xbegin :: x1 :: x2 :: x3 :: x4 ::x5 :: x6 :: x7 :: xlast :: [], ybegin ::y1 :: y2 :: _, ylast :: y-1 :: _) -> (
        let bold p1 p2 = stroke 1pt Color.black (Gr.line p1 p2) in
        [
          bold (xbegin, ybegin) (xbegin, ylast);
          bold (xbegin, ybegin) (xlast, ybegin);
          bold (xlast, ybegin) (xlast, ylast);
          bold (xbegin, ylast) (xlast, ylast);
          bold (xbegin, y1) (xlast, y1);
          bold (xbegin, y2) (xlast, y2);
          bold (xbegin, y-1) (xlast, y-1);
          bold (x1, y1) (x1, y-1);
          bold (x2, y1) (x2, ylast);
          bold (x3, y1) (x3, ylast);
          bold (x4, ybegin) (x4, ylast);
          bold (x5, y1) (x5, ylast);
          bold (x6, y1) (x6, ylast);
          bold (x7, y1) (x7, ylast);
        ]
      )
      | _ -> []
    in
    line-break true true ctx (tabular cells gen-line)

  let frontpage ctx r tbl =
    main-title ctx r +++ graduated-school-info ctx r +++ conversion-table ctx tbl

  let document credit-info tables =
    let page = A4Paper in
    let txtorg = (40pt, 35pt) in
    let hdrorg = (40pt, 20pt) in
    let ftrorg = (40pt, 780pt) in
    let txthgt = 630pt in
    let txtwid = 520pt in
    let (txtorgx, txtorgy) = txtorg in
    let ctx = get-standard-context txtwid in
    let pagecontf pbinfo =
      (|
        text-origin = (txtorgx, txtorgy);
        text-height = txthgt;
      |)
    in
    let pagepartsf pbinfo =
      (|
        header-origin = hdrorg;
        header-content = line-break true true ctx (header ctx);
        footer-origin = ftrorg;
        footer-content = block-nil;
      |)
    in
    let table1 = Option.from [] (List.nth 0 tables) in
    let frontpage = frontpage ctx credit-info table1 in
      page-break page pagecontf pagepartsf (frontpage)
end
